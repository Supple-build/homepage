/* ==========================================================================
objects.retain
Creates a wrapper around a block of content, centers, adds padding and
retains it to your desired size.
/  ========================================================================== */

@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use '../tools/internal';
@use '../tools/rem';

/* --------------------------------------------------------------------------
Functions
/  -------------------------------------------------------------------------- */

/**
 * If any of the values in `$areas` are in pixels, convert them to rems.
 */
@function compute-areas($areas) {
	$map: ();
	@each $key, $value in $areas {
		@if math.unit($value) == 'px' {
			$map: map.merge(
				$map,
				(
					$key: rem.convert($value),
				)
			);
		} @else {
			$map: map.merge(
				$map,
				(
					$key: $value,
				)
			);
		}
	}
	@return $map;
}

/* --------------------------------------------------------------------------
Variables
/  -------------------------------------------------------------------------- */

$areas: (
	'base': 640px,
	'popout': 960px,
	'feature': 1280px,
) !default;

$areas-computed: compute-areas($areas);
$area-names: map.keys($areas-computed);
$area-names-without-base: internal.list-remove($area-names, 'base');
$area-names-without-base-reversed: internal.list-reverse(
	$area-names-without-base
);

$start: null;
$end: null;
$textStart: null;
$textEnd: null;

@each $name in $area-names-without-base-reversed {
	$start: $start [#{$name}-start] minmax(0, var(--_s-o-retain-#{$name}-size));
}
@each $name in $area-names-without-base {
	$end: $end minmax(0, var(--_s-o-retain-#{$name}-size)) [#{$name}-end];
	$textStart: $textStart #{$name}-start;
	$textEnd: $textEnd
		minmax(0, calc(var(--_s-o-retain-#{$name}-size) * 2))
		[#{$name}-end];
}

/* --------------------------------------------------------------------------
Checks
/  -------------------------------------------------------------------------- */

/**
 * Check if `$areas` has the mandatory `base` entry
 */
@if not map.has-key($areas, 'base') {
	@error '`$areas` needs to retain atleast one entry named 'base'.';
}

/**
 * Check if all values in `$areas` are numbers and are not ems.
 */
@each $key, $value in $areas {
	@if type-of($value) == number {
		@if math.unit($value) == 'em' {
			@error 'Breakpoint `#{$key}: #{$value}` needs to be anything other than a `em` unit.';
		}
	} @else {
		@error '`#{$key}: #{$value}` needs to be a number.';
	}
}

/* --------------------------------------------------------------------------
Module
/  -------------------------------------------------------------------------- */

@layer objects {
	:where(.o-retain) {
		--_s-o-retain-padding-inline: var(
			--o-retain-padding-inline,
			var(--s-space-base, 1.5rem)
		);
		@each $key, $value in $areas-computed {
			--_s-o-retain-#{$key}-max-inline-size: var(
				--o-retain-#{$key}-max-inline-size,
				#{$value}
			);

			@if $key != 'base' {
				$previous-area: list.nth(
					$area-names,
					list.index($area-names, $key) - 1
				);
				--_s-o-retain-#{$key}-size: calc(
					(
							var(--_s-o-retain-#{$key}-max-inline-size) - var(
									--_s-o-retain-#{$previous-area}-max-inline-size
								)
						) /
						2
				);
			}
		}
		--_s-o-retain-columns: [full-bleed-start]
			minmax(var(--_s-o-retain-padding-inline), 1fr) [full-start]
			minmax(0, 100%) #{$start} [base-start] min(
				var(--_s-o-retain-base-max-inline-size),
				100% - var(--_s-o-retain-padding-inline) * 2
			) [base-end] #{$end} minmax(0, 100%) [full-end]
			minmax(var(--_s-o-retain-padding-inline), 1fr) [full-bleed-end];

		display: grid;
		grid-template-columns: var(--_s-o-retain-columns);
	}

	:where(.o-retain > *) {
		grid-column: var(--o-retain-column, var(--_s-o-retain-column, base));
	}

	@each $name in $area-names-without-base {
		:where(.o-retain--#{$name} > *),
		:where(.o-retain > .o-retain__#{$name}) {
			--_s-o-retain-column: #{$name};
		}
	}

	:where(.o-retain--full > *),
	:where(.o-retain > .o-retain__full) {
		--_s-o-retain-column: full;
	}

	:where(.o-retain--full-bleed > *),
	:where(.o-retain > .o-retain__full-bleed) {
		--_s-o-retain-column: full-bleed;
	}

	:where(.o-retain--text) {
		--_s-o-retain-columns: [base-start #{$textStart}]
			min(
				var(--_s-o-retain-base-max-inline-size),
				100% - var(--_s-o-retain-padding-inline) * 2
			)
			[base-end] #{$textEnd};
	}
}
